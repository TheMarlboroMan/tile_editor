#Tile editor

A map-level editor for tile based applications. It supports:

- Up to 6 (completely arbitrary) layers of tiles. Each one can have a different tileset and sizes.
- Up to 6 layers of logic objects. Each one can feed from a custom object notation.
- Basic meta-property editor, key-value pairs.
- In-application help (accesible by pressing F1).

Overall, it perfectly represents the aftertought after aftertought school of design, so the code is a wild mess wherever you look at it.

#Building

This project depends on libdansdl2.a and herramientas_proyecto, but not the versions in my repos but the patched ones in /dependencies.

If you choose to, you can compile with unpatched dependencies and risk runtime errors:

- libdansdl2.a, classic branch.
- herramientas_proyecto, classic branch.

For its input, it needs sprite sheets generated by this other tool:
	https://github.com/TheMarlboroMan/tabla_sprites

I am not sure this builds on Windows. There are many std::to_string shortcuts around and these tend to fail with mingw32.

##How to use

To get the application to work, you need a valid configuration file... The configuration file points to at least a single tileset data and a single object data. In case of failure, try checking the logs in data/logs.

Pressing F1 in the application brings up a help screen.

If you want to use the bundled example:

	./a.out res=800x600 out=ejemplo/result.dat cfg=ejemplo/config.dat

Notice that in this weird example, config.dat does point to other files, such as the tileset (tile.dat), its corresponding picture (default_tiles.png) and the logic objects configuration (objetos_config.dat).

Example configuration files are provided in the "ejemplo" directory... There is an example tileset in data/graficos.

Here follows a translation of the output of the tool, when used without parameters:

Use: executable res=WxH out=output_file cfg=config_file
	./a.out res=800x600 out=out.dat cfg=config.dat

PARAMETERS:
	res: Screen resolution expressed as width x height.
	out: Name of the output file. If the file exists, the map will be loaded.
	cfg: Name of the configuration file, made up of N lines with this format:

		T	sprite_sheet_name	comment_character	|	path_to_graphics	alpha	r_value_for_alpha	g_value_for_alpha	b_value_for_alpha
		T	sprite_sheet_name	comment_character	|	path_to_graphics	(for alpha channel pngs)
		O	path_to_object_definition

	The first T or O characters determine if the line defines a set of tiles or a set of objects. All sets specified will be loaded.

	Sprite sheets are generated with the "editor_sprites" tool.

	Object format is:
		id	name	width	height	fixed|resizable	default_color[r,g,b]
			property_name	default_value
			property_name	default_value
			property_name	default_value
		id	name	width	height	fixed|resizable	default_color[r,g,b]
			property_name	default_color
		[...]

	Such as in

		1	Start	32	32	fixed	32,32,32
			id	0
			bearing	90
		2	Exit	32	32	resizable	64,64,64
			map_id	0
			start_id	0

##Output file format...

There is no official extension for this. I use ".dat", but the output is actually a simple text file.

The thing does output in dnot (think json... before it was fashionable) but there was also a very simple "classic" structure. By default, the application will use the "dnot" format but will try to detect the kind of file when opening a new one. Classic files will be always saved with the classic format. It is, however, trivial to dive into the "controlador_rejilla.cpp" code and make the neccesary changes if this behaviour is undesirable.

There are a few differences between formats:

	- The dnot format saves additional presentational data, such as alpha values.
	- The dnot format allows to save and load width and height of logic objects. The classic format will basically ignore these.

This is the classic format. ! denotes a comment on this description, but the real file allows for no comments.

!Begin data. Only thing that closes, actually.
[ESTRUCTURA]
!Info block.
[INFO]
!First number indicates number of tile layers. Second indicates number of object layers.
1,1
!Init meta. Meta is a set of "key" and "value" completely dependant on the user.
[META]
categoria:1
ESTADO:"ACTIVO"
detonado:true
!End meta.
[/META]
!Begin grid matrix
[REJILLA]
!Width and height of the matrix, width and height of each cell, number of cells to get an horizontal or vertical separator, tileset used.
14,11,32,32,8,8,0
!Begin cells
[CELDAS]
!Groups of x, y and type.
0,0,64 1,0,78 2,0,78 3,0,78 4,0,78 5,0,78 6,0,1 7,0,1 8,0,78 9,0,78 10,0,78 11,0,78 12,0,78 13,0,64 0,1,44 1,1,73 2,1,73 3,1,73 4,1,73 5,1,73 6,1,68 7,1,68 8,1,73 9,1,73 10,1,73 11,1,73 12,1,73 13,1,44 0,2,44 1,2,5 2,2,6 3,2,6 4,2,6 5,2,6 6,2,9 7,2,9 8,2,6 9,2,6 10,2,6 11,2,6 12,2,7 13,2,44 0,3,44 1,3,8 2,3,17 3,3,12 4,3,12 5,3,12 6,3,12 7,3,12 8,3,12 9,3,12 10,3,12 11,3,18 12,3,10 13,3,44 0,4,44 1,4,8 2,4,10 11,4,8 12,4,10 13,4,44 0,5,44 1,5,8 2,5,10 3,5,78 4,5,78 5,5,78 6,5,78 7,5,78 8,5,78 9,5,78 10,5,78 11,5,8 12,5,10 13,5,44 0,6,44 1,6,8 2,6,10 3,6,73 4,6,75 5,6,73 6,6,73 7,6,77 8,6,73 9,6,75 10,6,73 11,6,8 12,6,10 13,6,44 0,7,44 1,7,8 2,7,9 3,7,9 4,7,9 5,7,9 6,7,9 7,7,9 8,7,9 9,7,9 10,7,9 11,7,9 12,7,10 13,7,44 0,8,44 1,8,11 2,8,12 3,8,12 4,8,12 5,8,12 6,8,9 7,8,9 8,8,12 9,8,12 10,8,12 11,8,12 12,8,13 13,8,44 0,9,44 1,9,44 2,9,44 3,9,44 4,9,44 5,9,44 6,9,66 7,9,66 8,9,44 9,9,44 10,9,44 11,9,44 12,9,44 13,9,44 0,10,63 1,10,63 2,10,63 3,10,63 4,10,63 5,10,63 6,10,2 7,10,2 8,10,63 9,10,63 10,10,63 11,10,63 12,10,63 13,10,63
!Begin logic
[LOGICA]
!Index of the logic object list to use.
0
!Begin objects
[OBJETOS]
!Groups of type, x, y and values for properties.
1,224,160,1,32
!An alternative notation includes names and values for the properties separated by ":".
1,224,160,propa:1,propb:32
!End data
[/ESTRUCTURA]

The [REJILLA] + [CELDAS] structure repeats once for each layer, same as the [LOGICA] + [OBJETOS] one.

The dnot structure is different, but symbolises similar data. The structure below has been expanded for readability. Again, the real one accepts no comments!!!

	reset();

	std::string filename="data/app_data/maps/"+fn;
	auto root=dnot_parse_file(filename);
:{				!Main block.
	layers:[		!Definition of tile layers. There is no count of file layers, but this is a vector so...
		{		!First block of layers... Layers are presented in order.
			data:[	!Definition of tiles....
				{t:1, x:5, y:0}, 	!t=type, x and y are in 0-based index.
				{t:1, x:8, y:10}],
			info:{	!Definition of layer structure..
				al:255, !Alpha of presentation.
				h:11, 	!Height
				hc:32, 	!Height of each cell, in pixels.
				hu:8, 	!Cells until horizontal ruler in editor.
				i:1, 	!Index of tileset used.
				w:14, 	!Width.
				wc:32, 	!Width of each cell, in pixels.
				wu:8}	!Cells until vertical ruler in editor.
			}, 	!End of first block of layers.
		{		!Second block of tile layers. Same data.
			data:[
				{t:64, x:0, y:0},
				{t:63, x:13, y:10}],
			info:{
				h:11,
				hc:32,
				hu:8,
				i:0,
				w:14,
				wc:32,
				wu:8}
			}
		], 		!End of all tile layers.
	logic:[			!Logic layers.
		{		!Begin first logic layer.
			data:[	!Data of first logic layer.
				{
					p:{bearing:"2"}, 	!Properties, in simple key-value notation.
					t:1, x:64, y:160}, 	!t is type. x and y are in pixels.
				{
					p:{active:"0"},
					t:4, x:352, y:160}
			],
			info:{i:1}	!Definition of layer structure, i is the tileset.
		},
		{		!Second tile layer, same structure.
			data:[
				{
					p:{bearing:"55", speed:"56"},
					t:1, x:160, y:64},
				{
					p:{tag:"666"},
					t:2, x:320, y:64}
			],
			info:{i:0}
		}
	], 			!End of all tile layers.
	meta:{			!Begin metadata. Always one key and one value, as strings.
		ESTADO:"activo",
		categoria:"1",
		detonado:"true"
	}
}

In all, the dnot format is larger and more verbose but much easier to parse and, most importantly, parseable with the utilities present in the repositories.

As a side note, data compression was considered at a point (bind together ranges of equal tiles, for example) but was discarded.

##History

- As of November 5th, 2015, the tool has been patched with a compatibility layer to support the many changes made to the original libdansdl2. Should the tool be updated, the compatibility layer will be removed. The tool now needs the SDL2_ttf library to link with (even though it's not used).
- As of July 2017 the dependencies have been added and the project has been patched to work with the bundled dependencies.-
- 19-7-2017: Added keyboard tile selection shortcuts.
- 21-7-2017: Many changes...
	- Added grid and file properties dialog.
	- Added also a little message in the bottom, to know what you are doing.
	- Fixed bug in tile selection shortcut.
	- Added background to tile selection list, to make it more usable.
	- Removed old bracket input to change tiles.
- 22-7-2017: Many more changes.
	- Added dnot export. Still not 100% functional.
	- Changed the way how properties work in objects, using a simple key->value sequence instead of the numerical index thing.
- 23-7-2017: Changes.
	- Added dnot export-import.
	- Fixed bug in dnot_parser, of course, only in the frozen branch here.
- 3-8-2017: Changes.
	- Added alpha to each layer so shadow layers can be done.
	- Added alpha and separator space to layer properties controller.
	- Added the possibility to change cell size, which previously was impossible without fiddling with the map files.
	- Also added this value to importers and exporters.
	- Changed a bit the structure of each layer to further presentational changes (such as background colours) can be changed easily.
	- Hacked the life away to support png alpha.
- 7-8-2017: Changes.
	- Added the possibility to change the size of logic objects... This actually has consequences in many places (loaders, exporters, logic editor...).

##Todo

- Load not only tileset, but also animation sets.
- Save visibility of each layer??

##Bugs

- There's a bug in the selector of tiles-objects, try changing layers.
- Fix tile page bug (try to switch pages with keyboard shortcuts).




{
	"<<START LAYERS>>":"",
	"layers": [
		{
			"<<START ONE LAYER>>":"",
			"data": [
				{
					"<<LAYERS HAVE TYPE, X AND Y": "",
					"t": 1,
					"x": 0,
					"y": 2,

				},
				{
					"t": 1,
					"x": 1,
					"y": 2
				},
				{
					"t": 2,
					"x": 2,
					"y": 2
				},
				{
					"t": 1,
					"x": 3,
					"y": 2
				},
				{
					"t": 1,
					"x": 4,
					"y": 2
				}
			],
			"<<LAYER METADATA": "",
			"info": {
					"<<THIS MUST BE THE ALPHA>>": "",
				"al": 255,
					"<<FULL LAYER H IN TILES>>": "",
				"h": 64,
					"<<CELL H IN PX>>": "",
				"hc": 32,
					"<<ADD A HORIZONTAL SEPARATOR EACH N CELLS >>": "",
				"hu": 8,
					"<<THIS MUST BE THE TILESET INDEX>>": "",
				"i": 0,
					"<<FULL LAYER W IN TILES>>": "",
				"w": 64,

					"<<CELL W IN PX>>": "",
				"wc": 32,
					"<<ADD A VERTIAL SEPARATOR EACH N CELLS >>": "",
				"wu": 8
			}
		},
		{
			"<<START OTHER LAYER>>":"",
			"data": [
				{
					"t": 4,
					"x": 0,
					"y": 2
				},
				{
					"t": 3,
					"x": 1,
					"y": 2
				},
				{
					"t": 8,
					"x": 2,
					"y": 2
				},
				{
					"t": 4,
					"x": 3,
					"y": 2
				},
				{
					"t": 3,
					"x": 4,
					"y": 2
				}
			],
			"info": {
				"al": 255,
				"h": 64,
				"hc": 32,
				"hu": 8,
				"i": 1,
				"w": 64,
				"wc": 32,
				"wu": : 8
			}
		}
	],
	"<<START LOGIC OBJECTS>>":"",
	"logic": [
		{
			"<<START LAYER>>":"",
		"data": [
				{
						"<<SPECIAL PROPERTIES>>":"",
					"p": {
						"bearing": "1", "id": "1"
					},
						"<<TYPE>>":"",
					"t": 1,
						"<<X>>":"",
					"x": 0,
						"<<Y>>":"",
					"y": 32
				},
				{
						"<<H, FOR NON FIXED>>":"",
					"h": 32,
						"<<SPECIAL PROPERTYES>>":"",
					"p": {
						"map_id": "1"
					},
					"t": 2,
						"<<W, FOR NON FIXED>>":"",
					"w": 32,
					"x": 128,
					"y": 32
				}
			],
				"<<START LAYER METADATA>>":"",
			"info": {
					"<<OBJECT SET INDEX>>":"",
				"i": 0
			}
		},
		{"data": [
				{"p": {},
					"t": 1,
					"x": 32,
					"y": 32
				},
				{"p": {},
					"t": 2,
					"x": 64,
					"y": 32
				},
				{"p": {},
					"t": 3,
					"x": 96,
					"y": 32
				}
			],
			"info": {
				"i": 1
			}
		}
	],
	"<<START MAP METADATA>>":"",
	"meta": {

	}
}

I can produce code that reads and saves this kind of format, however there are
some things I'd like to think about:

- I don't like how custom properties are always strings, there could be a type
	which would be easy to implement in object types, but hard to implement in
	map metadata without using some kind of formatting or template... I could
	think about that as long as we have very well defined types, such as
	int, double, string and bool.
	- The object files are no problem for this.
	- The map files... well, I guess we could have a particular template for
	these and be done with. There could be optional and non optional properties
	in a file defined like this:

beginproperty
	name bearing
	type number
	default 90
	comment Something something something
endproperty

- An object could be defined like this, which is a bit clearer than what we have
now. More verbose, but also easier to parse and extend.

beginobject
	id 1
	name start
	w 32
	h 32
	size fixed
	color 0,255,0
	beginproperty
		name id
		type number
		default 0
		comment Something something something
	endproperty
	beginproperty
		name bearing
		type number
		default 90
		comment Something something something
	endproperty
endobject

- An object could be defined like this, which is a bit clearer than what we have
now. More verbose, but also easier to parse and extend.

- The config file is horrendous:

	T	logic.txt	#	|	logic.png	0	0	0	0
	T	bg.txt	#	|	bg.png	0	0	0	0
	O	gates.txt
	O	objects.txt

We could transform it into

beginmapproperties
	file map_properties.txt
endmapproperties

begintileset
	file logic.txt
	comment #
	image logic.png
endtileset

begintileset
	file bg.txt
	comment #
	image bg.png
endtileset

beginobject
	file gates.txt
endobject

beginobject
	file objects.txt
endobject

So, to sum up, I should start by creating code that reads the configuration
file, property files, tileset files and object files. Each of these could
share stuff, mainly the property types and some sort of parser which produces
a "propertyname" or "verb" and its associated vaalue.

